#!/bin/sh
#
# @author Ren√© Schwaiger <sanssecours@me.com>
# @brief Reformats Shell source code
# @date 07.09.2018
# @tags reformat

SCRIPTS_DIR=$(dirname "$0")
. "${SCRIPTS_DIR}/include-common"

cd "$SOURCE"

if ! which shfmt > /dev/null; then
	printf 2>&1 'Please install `shfmt`\n'
	exit 1
fi

shell_files=$(shfmt -f 'scripts' 'src' 'tests/shell')
non_ignored=$(printf "%s\n" "$shell_files" | sed -nE 's/(.*)/'"'"'\1'"'"'/p' | xargs git check-ignore -vn | sed -nE 's/^::[[:blank:]]*(.*)$/\1/p')
printf "%s\n" "$non_ignored" | sed -nE 's/(.*)/'"'"'\1'"'"'/p' | xargs shfmt -s -sr -w
shfmt -s -sr -w 'tests/shell/include_common.sh.in'

end_line=$(grep -n '^### END OF INCLUDE FILE ###$' 'tests/shell/include_common.sh.in' | cut -d':' -f1)

if [ -z "$end_line" ]; then
	printf 2>&1 'tests/shell/include_common.sh.in must contain the line "### END OF INCLUDE FILE ###" to indicate the end of the actual file content\n'
	exit 1
fi

if [ "$end_line" -ge 1000 ]; then
	printf 2>&1 'tests/shell/include_common.sh.in too long only 999 lines allowed.\n'
	exit 1
fi

comment_lines=$((999 - end_line))
head -n "$end_line" 'tests/shell/include_common.sh.in' > a.tmp && mv a.tmp 'tests/shell/include_common.sh.in'
printf "%${comment_lines}s" | sed 's/ /#\n/g' >> 'tests/shell/include_common.sh.in'
echo "# empty lines up to 1000 so that line numbers in the resulting scripts are more useful" >> 'tests/shell/include_common.sh.in'
