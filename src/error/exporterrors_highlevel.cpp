/**
 * @file
 *
 * @brief
 *
 * @copyright BSD License (see LICENSE.md or https://www.libelektra.org)
 */

#include "parser.hpp"

#include <algorithm>
#include <cstring>
#include <fstream>
#include <functional>
#include <iostream>

#ifndef _WIN32
#include <fcntl.h>
#include <unistd.h>
#endif

using namespace std;

static ostream & printCreatorSignature (ostream & os, map<string, string> & data)
{
	string name = data["name"];
	bool wasUnderscore = true;
	for (char & cur : name)
	{
		if (isalpha (cur))
		{
			if (wasUnderscore)
			{
				cur = static_cast<char> (toupper (cur));
			}
			else
			{
				cur = static_cast<char> (tolower (cur));
			}
		}
		wasUnderscore = cur == '_';
	}
	name.erase (remove (name.begin (), name.end (), '_'), name.end ());

	os << "ElektraError * elektraError" << name << "(";

	string severity = data["severity"];

	int args = data.find ("args") != data.end () ? stoi (data["args"]) : 0;
	if (args > 0)
	{
		if (severity == "*")
		{
			os << "ElektraErrorSeverity severity, ";
		}

		os << data["type1"] << " " << data["arg1"];
		for (int j = 2; j <= args; j++)
		{
			os << ", " << data["type" + to_string (j)] << " " << data["arg" + to_string (j)];
		}
	}

	os << ")";
	return os;
}

static ostream & printCodes (ostream & os, parse_t & p)
{
	os << "/*This is an auto-generated file generated by exporterrors_highlevel. Do not modify it.*/" << endl
	   << endl
	   << "#ifndef ELEKTRA_ERROR_CODES_H" << endl
	   << "#define ELEKTRA_ERROR_CODES_H" << endl
	   << endl
	   << "#ifdef __cplusplus" << endl
	   << "extern \"C\" {" << endl
	   << "#endif" << endl
	   << "typedef enum" << endl
	   << "{" << endl;

	for (size_t i = 1; i < p.size (); ++i)
	{
		if (p[i]["unused"] == "yes")
		{
			continue;
		}

		if (p[i]["name"].empty ())
		{
			continue;
		}

		os << "\tELEKTRA_ERROR_CODE_" << p[i]["name"] << " = " << i << "," << endl;
	}

	os << "} ElektraErrorCode;" << endl;
	os << endl;

	os << "#ifdef __cplusplus" << endl << "}" << endl;

	os << "namespace elektra {" << endl;
	os << "enum class ElektraErrorCode {" << endl;
	for (size_t i = 1; i < p.size (); ++i)
	{
		if (p[i]["unused"] == "yes")
		{
			continue;
		}

		if (p[i]["name"].empty ())
		{
			continue;
		}

		os << "\t" << p[i]["name"] << " = ELEKTRA_ERROR_CODE_" << p[i]["name"] << "," << endl;
	}
	os << "};" << endl;
	os << "}" << endl;

	os << "#endif" << endl;

	os << "#endif // ELEKTRA_ERROR_CODES_H" << endl;
	os << endl;
	return os;
}

static ostream & printPublic (ostream & os, parse_t & p)
{
	os << "/*This is an auto-generated file generated by exporterrors_highlevel. Do not modify it.*/" << endl
	   << endl
	   << "#ifndef ELEKTRA_ERRORS_H" << endl
	   << "#define ELEKTRA_ERRORS_H" << endl
	   << endl
	   << "#include <elektra/types.h>" << endl
	   << "#include <elektra/error.h>" << endl
	   << endl
	   << "#ifdef __cplusplus" << endl
	   << "extern \"C\" {" << endl
	   << "#endif" << endl;

	for (size_t i = 1; i < p.size (); ++i)
	{
		if (p[i]["unused"] == "yes")
		{
			continue;
		}

		if (p[i]["name"].empty ())
		{
			continue;
		}

		if (p[i]["visibility"] != "public")
		{
			continue;
		}

		printCreatorSignature (os, p[i]) << ";" << endl;
	}
	os << endl;

	os << "#ifdef __cplusplus" << endl << "}" << endl << "#endif" << endl;

	os << "#endif // ELEKTRA_ERRORS_H" << endl;
	os << endl;
	return os;
}

static ostream & printPrivate (ostream & os, parse_t & p)
{
	os << "/*This is an auto-generated file generated by exporterrors_highlevel. Do not modify it.*/" << endl
	   << endl
	   << "#ifndef ELEKTRA_ERRORS_PRIVATE_H" << endl
	   << "#define ELEKTRA_ERRORS_PRIVATE_H" << endl
	   << endl
	   << "#include <elektra/types.h>" << endl
	   << "#include <elektra/error.h>" << endl
	   << endl
	   << "#ifdef __cplusplus" << endl
	   << "extern \"C\" {" << endl
	   << "#endif" << endl;

	for (size_t i = 1; i < p.size (); ++i)
	{
		if (p[i]["unused"] == "yes")
		{
			continue;
		}

		if (p[i]["name"].empty ())
		{
			continue;
		}

		if (p[i]["visibility"] == "public")
		{
			continue;
		}

		printCreatorSignature (os, p[i]) << ";" << endl;
	}
	os << endl;

	os << "#ifdef __cplusplus" << endl << "}" << endl << "#endif" << endl;

	os << "#endif // ELEKTRA_ERRORS_PRIVATE_H" << endl;
	os << endl;
	return os;
}

static ostream & printSource (ostream & os, parse_t & p, const char * headerPublic, const char * headerPrivate)
{
	os << "/*This is an auto-generated file generated by exporterrors_highlevel. Do not modify it.*/" << endl
	   << endl
	   << "#include <" << headerPublic << ">" << endl
	   << "#include <" << headerPrivate << ">" << endl
	   << "#include <kdbprivate.h>" << endl
	   << "#include <kdbhelper.h>" << endl
	   << endl;

	for (size_t i = 1; i < p.size (); ++i)
	{
		if (p[i]["unused"] == "yes")
		{
			continue;
		}

		if (p[i]["name"].empty ())
		{
			continue;
		}

		printCreatorSignature (os, p[i]) << endl << "{" << endl;

		string severity = p[i]["severity"];


		if (severity != "*")
		{
			std::transform (severity.begin (), severity.end (), severity.begin (), ::toupper);
			os << "\tElektraErrorSeverity severity = "
			   << "ELEKTRA_ERROR_SEVERITY_" << severity << ";" << endl;
		}

		int args = p[i].find ("args") != p[i].end () ? stoi (p[i]["args"]) : 0;

		if (args > 0)
		{
			os << "\tchar * errorString = elektraFormat (\"" << p[i]["description"] << "\"";
			for (int j = 1; j <= args; j++)
			{
				os << ", " << p[i]["arg" + std::to_string (j)];
			}
			os << ");" << endl;
		}
		else
		{
			os << "\tconst char * errorString = \"" << p[i]["description"] << "\"";
		}

		os << "\tElektraError * error = elektraErrorCreate (ELEKTRA_ERROR_CODE_" << p[i]["name"] << ", errorString, severity);"
		   << endl;

		if (args > 0)
		{
			os << "\telektraFree (errorString);" << endl;
		}

		os << "\treturn error;" << endl;
		os << "}" << endl;
		os << endl;
	}

	return os;
}

template <typename Func>
static int writeFile (parse_t & data, const char * filename, Func printFn)
{
	std::string tmpfile = filename;
#ifndef _WIN32
	tmpfile += ".tmp";
	tmpfile += to_string (getpid ());
#endif
	{
		ofstream fout (tmpfile);
		if (!fout.is_open ())
		{
			cerr << "Could not open output file " << filename << endl;
			return 1;
		}
		printFn (fout, data);
	}

#ifndef _WIN32
	int fd = open (tmpfile.c_str (), O_RDWR);
	if (fd == -1)
	{
		cerr << "Could not reopen file " << filename << endl;
		return 2;
	}
	if (fsync (fd) == -1)
	{
		cerr << "Could not fsync config file " << filename << " because ", strerror (errno);
		close (fd);
		return 3;
	}
	close (fd);

	if (rename (tmpfile.c_str (), filename) == -1)
	{
		cerr << "Could not rename file " << tmpfile << " to " << filename << endl;
		return 4;
	}
#endif
	return 0;
}

int main (int argc, char ** argv) try
{
	switch (argc)
	{
	case 2:
	{
		string infile = argv[1];
		parse_t data = parse (infile);
		printCodes (cout, data);
		cout << endl << endl;
		printPublic (cout, data);
		cout << endl << endl;
		printPrivate (cout, data);
		cout << endl << endl;
		printSource (cout, data, "", "");
		break;
	}
	case 8:
	{
		string infile = argv[1];
		parse_t data = parse (infile);
		writeFile (data, argv[2], printCodes);
		writeFile (data, argv[3], printPublic);
		writeFile (data, argv[4], printPrivate);

		auto func = [&](ostream & os, parse_t & d) { printSource (os, d, argv[6], argv[7]); };

		writeFile (data, argv[5], func);
		break;
	}
	default:
		cerr << "Usage " << argv[0] << " infile [outpublic outprivate outsource]" << endl;
		return 1;
	}

	return 0;
}
catch (parse_error const & e)
{
	cerr << "The line " << e.linenr << " caused following parse error: " << e.info << endl;
	return -1;
}
